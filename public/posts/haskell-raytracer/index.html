<!doctype html>
<html lang="en-us">
  <head>
    <title>Parallelizing Haskell Raytracer // theblek</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.136.5">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Kuklin Georgiy" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.5b1fcc8902588589c4767187402a3c29f8b8d7a6fdef6d9f8f77045bb0d14fee.css" />
    

    
    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Parallelizing Haskell Raytracer">
  <meta name="twitter:description" content="This is just a translation of my article from 2023. Stylistic choices of the original are mostly retained. It will not be substantially expanded upon, but I do feel this article could benefit from better methodology. More on that later. You can read original in russian here: https://luxurious-yearde9.notion.site/Parallel-Haskell-raytracer-63132332960f488aaa04b7cc01e13f8e.
Introduction So we made a raytracer in haskell using Raytracing In One Weekend as our guide. As you may know, haskell’s biggest feature is mathematically correct functions. Meaning the result of the evaluation can be determined solely from the arugments. So no more global or hidden state. This computing models lends itself great to parrallel execution. However there were a few unexpected pitfalls that I want to share.">

    <meta property="og:url" content="https://theblek.online/posts/haskell-raytracer/">
  <meta property="og:site_name" content="theblek">
  <meta property="og:title" content="Parallelizing Haskell Raytracer">
  <meta property="og:description" content="This is just a translation of my article from 2023. Stylistic choices of the original are mostly retained. It will not be substantially expanded upon, but I do feel this article could benefit from better methodology. More on that later. You can read original in russian here: https://luxurious-yearde9.notion.site/Parallel-Haskell-raytracer-63132332960f488aaa04b7cc01e13f8e.
Introduction So we made a raytracer in haskell using Raytracing In One Weekend as our guide. As you may know, haskell’s biggest feature is mathematically correct functions. Meaning the result of the evaluation can be determined solely from the arugments. So no more global or hidden state. This computing models lends itself great to parrallel execution. However there were a few unexpected pitfalls that I want to share.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-19T18:27:50+03:00">
    <meta property="article:modified_time" content="2025-06-19T18:27:50+03:00">


  </head>
  <body>
    <header class="app-header">
      <a href="/"><img class="app-header-avatar" src="/myavatar.jpg" alt="Kuklin Georgiy" /></a>
      <span class="app-header-title">theblek</span>
      <p>Software engineer interested in the nitty-gritty of computing</p>
      <div class="app-header-social">
        
          <a href="https://github.com/TheBlek" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentColor"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
          </a>
        
          <a href="https://t.me/theblek_games" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-telegram" viewBox="0 0 24 24" fill="currentColor"><title>Telegram</title><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/></svg>
          </a>
        
          <a href="mailto:theblekbern@gmail.com" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-mail" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>mail</title><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Parallelizing Haskell Raytracer</h1>
      <div class="post-meta">
        <div>
          <svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
          Jun 19, 2025
        </div>
        <div>
          <svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
          12 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <blockquote>
<p>This is just a translation of my article from 2023. Stylistic choices of the original are mostly retained. It will not be substantially expanded upon, but I do feel this article could benefit from better methodology. More on that later. You can read original in russian here: <a href="https://luxurious-yearde9.notion.site/Parallel-Haskell-raytracer-63132332960f488aaa04b7cc01e13f8e">https://luxurious-yearde9.notion.site/Parallel-Haskell-raytracer-63132332960f488aaa04b7cc01e13f8e</a>.</p>
</blockquote>
<h1 id="introduction">Introduction</h1>
<p>So we made a raytracer in haskell using <a href="https://raytracing.github.com">Raytracing In One Weekend</a> as our guide.
As you may know, haskell&rsquo;s biggest feature is mathematically correct functions. Meaning the result of the evaluation can be determined solely from the arugments. So no more global or hidden state. This computing models lends itself great to parrallel execution. However there were a few unexpected pitfalls that I want to share.</p>
<p>While measuring performance benefit of parallelizing I also became interested in how fast it can go. Hence a second part about optimisations.</p>
<p>All of the code is available at <a href="https://github.com/TheBlek/haskell-raytracer">https://github.com/TheBlek/haskell-raytracer</a></p>
<h1 id="baseline-measurements">Baseline measurements</h1>
<p>For all measurements I&rsquo;m going to use three configurations:</p>
<pre tabindex="0"><code>Small: 11.33s (Avg 3)
Medium: 94.5s (Avg 3)
Big: 408.93s (Just 1)
</code></pre><p>Everything later will be measured one-shot.</p>
<h1 id="threads-go-brrr">Threads go brrr</h1>
<p>Having downloaded package <code>parallel</code>, I replaced following line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">write_file</span> <span style="color:#e6db74">&#34;output.ppm&#34;</span> (evalState colors (mkStdGen <span style="color:#ae81ff">0</span>))
</span></span></code></pre></div><p>with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">write_file</span> <span style="color:#e6db74">&#34;output.ppm&#34;</span> (evalState colors (mkStdGen <span style="color:#ae81ff">0</span>) `using` parList rseq)
</span></span></code></pre></div><p>Just calculating an array of colors for each pixel in parallel. And&hellip;</p>
<p>12 seconds for small configuration&hellip;</p>
<p>And I could see only one thread in htop.</p>
<p>That&rsquo;s because mutlithreading needs to be turned on at compile time:</p>
<pre tabindex="0"><code>ghc-options: 
    -threaded 
    -rtsopts 
    -with-rtsopts=-N -- Can pass number of threads to limit (-N4)
</code></pre><p>Now we are ready to take off!</p>
<p><img src="/haskell-htop.webp" alt="How it look in htop"></p>
<p>Looking good!</p>
<p>Wait, what?&hellip;</p>
<p>24 seconds on the small test?&hellip; From baseline of 11.3?!</p>
<p>Something&rsquo;s wrong here.</p>
<p>This might happen because of resource contension between threads. And we actually have a resource that we &ldquo;share&rdquo; - random number generator. We can&rsquo;t generate random numbers for one pixel until we have done so for previous pixel. Otherwise numbers will be the same for each pixel and won&rsquo;t be random. And empirically that leads to artifacts in the image. So what do we when we actually want to share?</p>
<blockquote>
<p>Looking at this code now in 2025, I&rsquo;m not sure anymore what caused such a massive slowdown. Maybe it&rsquo;s because of spawning so many thread simutaneously? I mean, obviously, it wasn&rsquo;t &ldquo;sharing&rdquo;. Remember - no direct sharing in haskell. However, fundamentally we <em>needed</em> to share pRNG. And that certainly is a limiter. I&rsquo;m not even sure what the code written the first time parallelized&hellip;</p>
</blockquote>
<p>Our case is pretty simple - we can create any number of pRNGs and use each of them sequentially:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> accumulated_color <span style="color:#f92672">=</span> [multi_color objs u v (floor samples_per_pixel)<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>            v <span style="color:#f92672">&lt;-</span>  reverse [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>(image_height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">..</span><span style="color:#ae81ff">1</span>], 
</span></span><span style="display:flex;"><span>            u <span style="color:#f92672">&lt;-</span>  [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>(image_width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">..</span><span style="color:#ae81ff">1</span>]]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> image_height <span style="color:#f92672">*</span> image_width
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> part_len <span style="color:#f92672">=</span> len <span style="color:#f92672">/</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> map_colors <span style="color:#f92672">=</span> mapM (fmap (adjust_gamma <span style="color:#ae81ff">2</span> <span style="color:#f92672">.</span> average samples_per_pixel))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> st_colors <span style="color:#f92672">=</span> map map_colors (chunksOf (floor part_len) accumulated_color)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> colors_parts <span style="color:#f92672">=</span> zipWith (<span style="color:#a6e22e">\</span>st i <span style="color:#f92672">-&gt;</span> evalState st (mkStdGen i)) st_colors [<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> colors <span style="color:#f92672">=</span> concat (colors_parts `using` parList rseq)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">write_file</span> <span style="color:#e6db74">&#34;output.ppm&#34;</span> colors
</span></span></code></pre></div><p>Running small test we get 13 seconds. That&rsquo;s better, but still bad. What am I doing wrong?</p>
<h2 id="haskell-is-a-lazy-capybara">Haskell is a lazy capybara</h2>
<p>Turns out, problem was because of haskell does not evaluate anything immediately. It stores objects that describe the calculation that is evaluated on demand.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>sprint x
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">_</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> seq x ()
</span></span><span style="display:flex;"><span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>sprint x
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>That also applies to <em>constructors of types</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">let</span> z <span style="color:#f92672">=</span> swap (x, x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>sprint z
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">_</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> seq z ()
</span></span><span style="display:flex;"><span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>sprint z
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">_</span>,<span style="color:#66d9ef">_</span>)
</span></span></code></pre></div><p>As you can notice, field values remain uncomputed. As it turns out, <code>seq</code> will not go deeper than one level. To compute field values, you need to demand them:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> fst z
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>sprint z
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> (<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">3</span>)
</span></span></code></pre></div><p>In this case, first field (x + 1) was dependent upon evaluation of x so haskell automatically calculated x. And second field happened to be x, hence its evaluated.</p>
<p>The function that we used to calculate list in parallel - <code>parList</code> - just uses <code>seq</code> on each of the list element in parallel. You can probably see the problem:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Color</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Cl</span> {color<span style="color:#f92672">::</span><span style="color:#66d9ef">Vec3</span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">---</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">let</span> color <span style="color:#f92672">=</span> blue
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>sprint color
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">color</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">_</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> seq color ()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">color</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Cl</span> <span style="color:#66d9ef">_</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">---</span>
</span></span><span style="display:flex;"><span>[<span style="color:#66d9ef">Cl</span> <span style="color:#66d9ef">_</span>, <span style="color:#66d9ef">Cl</span> <span style="color:#66d9ef">_</span>, <span style="color:#f92672">...</span>]
</span></span></code></pre></div><p>And actual colors were calculated when function writing the image needed them.</p>
<p>For solving this problem there is a class <code>RNFData</code> in the <code>deepseq</code> package. This class has a single function that has to make haskell evaluate a value completely. For parallelizing computation of colors we needed to specify the behaviour for our types:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">NFData</span> <span style="color:#66d9ef">Color</span> <span style="color:#66d9ef">where</span> 
</span></span><span style="display:flex;"><span>    rnf (<span style="color:#66d9ef">Cl</span> x) <span style="color:#f92672">=</span> rnf x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">NFData</span> <span style="color:#66d9ef">Vec3</span> <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    rnf (<span style="color:#66d9ef">Vc3</span> x y z) <span style="color:#f92672">=</span> seq x <span style="color:#f92672">$</span> seq y <span style="color:#f92672">$</span> seq z ()
</span></span></code></pre></div><p>Then replace one line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> colors <span style="color:#f92672">=</span> concat (colors_parts `using` parList rdeepseq)
</span></span></code></pre></div><p>And finally a W:</p>
<pre tabindex="0"><code>Small: 8s (~1.41x)
Medium: 64s (~1.47x)
Big: 277s (~1.48x)
</code></pre><p>For a machine with two real cores, the result looks as expected. Seeing those numbers stired up my interest in optimisations.</p>
<h1 id="optimisations-go-brrr">Optimisations go brrr</h1>
<h2 id="still-threads">Still threads</h2>
<p>On the previous step we divided colors into 4 parts because my working machine had 4 threads, but is it optimal?</p>
<p>So I decided to check two other divisions: by rows and by columns. With typical screen ratio 16 by 9, that would make more columns than rows.</p>
<blockquote>
<p>Note, from here on out I will specify speedup in parethesis relative to previous-best results.</p>
</blockquote>
<p>Row split:</p>
<pre tabindex="0"><code>Small: 7.13s (1.12x)
Medium: 57.95s (1.10x)
Big: 260s (1.07x)
</code></pre><p>Column split:</p>
<pre tabindex="0"><code>Small: 7.12s (1.12x)
Medium: 62.8s (1.02x)
Big: 249s (1.11x)
</code></pre><p>As you can see, column and row splits give results within a margin of error. However its clear that its better to divide on more parts than just 4.</p>
<h2 id="the-easiest">The easiest</h2>
<p>Easiest optimisation are just compiler flags:</p>
<pre tabindex="0"><code>-funfolding-use-threshold=16
-optc-O3
-optc-ffast-math
-fspecialise-aggressively
-fexpose-all-unfoldings
&#34;-with-rtsopts=-N -s -A64M&#34;
</code></pre><p>This gives us:</p>
<pre tabindex="0"><code>Small: 6.61s (1.078x)
Medium: 55.9s (1.055x)
Big: 233.9s (1.069x)
</code></pre><p>Its not much, but its honest work. Especially not having done anything :)</p>
<h2 id="wizardry">Wizardry</h2>
<p>In search of further optimisation opportunities I run the program under a profiler to see which functions are the heaviest or hottest. First two lines are not surprising unlike next three. Sure, we are doing a lot of Vec-number multiplications, but why are they not inlining?</p>
<blockquote>
<p>Note: &laquo;* and *&raquo; are our operators to multiply 3d vector with a number</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">COST</span> <span style="color:#66d9ef">CENTRE</span>         <span style="color:#66d9ef">MODULE</span>                    <span style="color:#f92672">%</span>time <span style="color:#f92672">%</span>alloc
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sphere_intersection</span> <span style="color:#66d9ef">Hittable</span>                  <span style="color:#ae81ff">16.2</span>   <span style="color:#ae81ff">13.5</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_dist</span>            <span style="color:#66d9ef">Hittable</span>                  <span style="color:#ae81ff">16.1</span>   <span style="color:#ae81ff">12.7</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;&lt;*</span>                 <span style="color:#66d9ef">Vec3</span>                      <span style="color:#ae81ff">6.1</span>   <span style="color:#ae81ff">11.3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">length_sqr</span>          <span style="color:#66d9ef">Vec3</span>                      <span style="color:#ae81ff">6.0</span>    <span style="color:#ae81ff">5.1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">*&gt;&gt;</span>                 <span style="color:#66d9ef">Vec3</span>                      <span style="color:#ae81ff">5.2</span>    <span style="color:#ae81ff">5.0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_nearest_sph</span>     <span style="color:#66d9ef">Hittable</span>                  <span style="color:#ae81ff">4.1</span>    <span style="color:#ae81ff">4.7</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">scatter</span>             <span style="color:#66d9ef">Material</span>                  <span style="color:#ae81ff">4.0</span>    <span style="color:#ae81ff">3.7</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">randomRS</span>            <span style="color:#66d9ef">MyRandom</span>                  <span style="color:#ae81ff">3.8</span>    <span style="color:#ae81ff">4.3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">color_ray</span>           <span style="color:#66d9ef">Main</span>                      <span style="color:#ae81ff">3.7</span>    <span style="color:#ae81ff">3.5</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_point</span>           <span style="color:#66d9ef">Hittable</span>                  <span style="color:#ae81ff">3.1</span>    <span style="color:#ae81ff">3.9</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_dist</span>            <span style="color:#66d9ef">Hittable</span>                  <span style="color:#ae81ff">3.0</span>    <span style="color:#ae81ff">3.0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_normal</span>          <span style="color:#66d9ef">Hittable</span>                  <span style="color:#ae81ff">3.0</span>    <span style="color:#ae81ff">1.9</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">random_vec</span>          <span style="color:#66d9ef">MyRandom</span>                  <span style="color:#ae81ff">2.8</span>    <span style="color:#ae81ff">4.0</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                   <span style="color:#66d9ef">Vec3</span>                      <span style="color:#ae81ff">2.7</span>    <span style="color:#ae81ff">2.3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">atPoint</span>             <span style="color:#66d9ef">Ray</span>                       <span style="color:#ae81ff">2.5</span>    <span style="color:#ae81ff">3.3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">multi_color</span>         <span style="color:#66d9ef">Main</span>                      <span style="color:#ae81ff">2.2</span>    <span style="color:#ae81ff">2.3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">gen_ray</span>             <span style="color:#66d9ef">Main</span>                      <span style="color:#ae81ff">1.9</span>    <span style="color:#ae81ff">2.5</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">headMay</span>             <span style="color:#66d9ef">Safe</span>                      <span style="color:#ae81ff">1.2</span>    <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_data</span>            <span style="color:#66d9ef">Hittable</span>                  <span style="color:#ae81ff">1.1</span>    <span style="color:#ae81ff">0.4</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">reflect</span>             <span style="color:#66d9ef">Material</span>                  <span style="color:#ae81ff">1.0</span>    <span style="color:#ae81ff">1.3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">blend</span>               <span style="color:#66d9ef">Color</span>                     <span style="color:#ae81ff">0.9</span>    <span style="color:#ae81ff">1.7</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;&lt;\</span>                 <span style="color:#66d9ef">Vec3</span>                      <span style="color:#ae81ff">0.9</span>    <span style="color:#ae81ff">1.2</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">nextWord64</span>          <span style="color:#66d9ef">System</span><span style="color:#f92672">.</span><span style="color:#66d9ef">Random</span><span style="color:#f92672">.</span><span style="color:#66d9ef">SplitMix</span>    <span style="color:#ae81ff">0.8</span>    <span style="color:#ae81ff">3.6</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">absorb</span>              <span style="color:#66d9ef">Color</span>                     <span style="color:#ae81ff">0.6</span>    <span style="color:#ae81ff">1.2</span>
</span></span></code></pre></div><p>Well, lets help the compiler aka do the work for it by inserting <code>INLINE</code> statements on all vector operations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#75715e">{-# INLINE (*&gt;&gt;) #-}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">{-# INLINE (&lt;&lt;*) #-}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">{-# INLINE (&lt;&lt;\) #-}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">{-# INLINE dot #-}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">{-# INLINE length_sqr #-}</span>
</span></span></code></pre></div><p>Results:</p>
<pre tabindex="0"><code>Small: 4.93s (1.34x)
Medium: 40.68s (1.37x)
Big: 173.24s (1.35x)
</code></pre><p>Wow! This speedup is comparable with going mutltithreading! 5 lines gave ~35%! But wait, there is more. Resulting program can be profiled again:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">COST</span> <span style="color:#66d9ef">CENTRE</span>           <span style="color:#66d9ef">MODULE</span>                 <span style="color:#f92672">%</span>time <span style="color:#f92672">%</span>alloc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_dist</span>              <span style="color:#66d9ef">Hittable</span>               <span style="color:#ae81ff">20.5</span>   <span style="color:#ae81ff">15.4</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sphere_intersection</span>   <span style="color:#66d9ef">Hittable</span>               <span style="color:#ae81ff">11.4</span>   <span style="color:#ae81ff">16.6</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">randomRS</span>              <span style="color:#66d9ef">MyRandom</span>               <span style="color:#ae81ff">5.5</span>    <span style="color:#ae81ff">5.2</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_nearest_sph</span>       <span style="color:#66d9ef">Hittable</span>               <span style="color:#ae81ff">5.5</span>    <span style="color:#ae81ff">5.7</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">color_ray</span>             <span style="color:#66d9ef">Main</span>                   <span style="color:#ae81ff">5.1</span>    <span style="color:#ae81ff">4.1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_normal</span>            <span style="color:#66d9ef">Hittable</span>               <span style="color:#ae81ff">4.8</span>    <span style="color:#ae81ff">3.8</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">scatter</span>               <span style="color:#66d9ef">Material</span>               <span style="color:#ae81ff">4.7</span>    <span style="color:#ae81ff">3.7</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_point</span>             <span style="color:#66d9ef">Hittable</span>               <span style="color:#ae81ff">4.4</span>    <span style="color:#ae81ff">5.5</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_dist</span>              <span style="color:#66d9ef">Hittable</span>               <span style="color:#ae81ff">3.9</span>    <span style="color:#ae81ff">3.7</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">random_vec</span>            <span style="color:#66d9ef">MyRandom</span>               <span style="color:#ae81ff">3.8</span>    <span style="color:#ae81ff">4.9</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">gen_ray</span>               <span style="color:#66d9ef">Main</span>                   <span style="color:#ae81ff">3.2</span>    <span style="color:#ae81ff">3.1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">atPoint</span>               <span style="color:#66d9ef">Ray</span>                    <span style="color:#ae81ff">3.1</span>    <span style="color:#ae81ff">4.0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">norm</span>                  <span style="color:#66d9ef">Vec3</span>                   <span style="color:#ae81ff">3.1</span>    <span style="color:#ae81ff">6.0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">multi_color</span>           <span style="color:#66d9ef">Main</span>                   <span style="color:#ae81ff">3.1</span>    <span style="color:#ae81ff">2.8</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">+</span>                     <span style="color:#66d9ef">Vec3</span>                   <span style="color:#ae81ff">2.4</span>    <span style="color:#ae81ff">1.6</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">headMay</span>               <span style="color:#66d9ef">Safe</span>                   <span style="color:#ae81ff">1.6</span>    <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_data</span>              <span style="color:#66d9ef">Hittable</span>               <span style="color:#ae81ff">1.6</span>    <span style="color:#ae81ff">0.5</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">absorb</span>                <span style="color:#66d9ef">Color</span>                  <span style="color:#ae81ff">1.4</span>    <span style="color:#ae81ff">1.5</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span>                     <span style="color:#66d9ef">Vec3</span>                   <span style="color:#ae81ff">1.2</span>    <span style="color:#ae81ff">0.9</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">reflect</span>               <span style="color:#66d9ef">Material</span>               <span style="color:#ae81ff">1.2</span>    <span style="color:#ae81ff">1.7</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">nextWord64</span>            <span style="color:#66d9ef">System</span><span style="color:#f92672">.</span><span style="color:#66d9ef">Random</span><span style="color:#f92672">.</span><span style="color:#66d9ef">SplitMix</span> <span style="color:#ae81ff">1.2</span>    <span style="color:#ae81ff">4.4</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">random_vec_in_sphereS</span> <span style="color:#66d9ef">MyRandom</span>               <span style="color:#ae81ff">1.1</span>    <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">blend</span>                 <span style="color:#66d9ef">Color</span>                  <span style="color:#ae81ff">1.0</span>    <span style="color:#ae81ff">1.4</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">liftMay</span>               <span style="color:#66d9ef">Safe</span><span style="color:#f92672">.</span><span style="color:#66d9ef">Util</span>              <span style="color:#ae81ff">0.9</span>    <span style="color:#ae81ff">1.0</span>
</span></span></code></pre></div><p>You can see here the rest of vector operations, simple ray and color function as well as generating random numbers. Let&rsquo;s enchant them as well:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#75715e">{-# INLINE randomRS #-}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">{-# INLINE atPoint #-}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">{-# INLINE norm #-}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">{-# INLINE absorb #-}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">{-# INLINE blend #-}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">{-# INLINE (&lt;++&gt;) #-}</span> <span style="color:#75715e">-- Just for fun</span>
</span></span></code></pre></div><p>That gives total result of inlining at:</p>
<pre tabindex="0"><code>Small: 4.53s (1.46x)
Medium: 38.79s (1.44x)
Big: 161.6s (1.45x)
</code></pre><p>That&rsquo;s a little better. Now to firmly at the level of going multithreading. But wait there is more. Doing it once again yields following total results of inlining:</p>
<pre tabindex="0"><code>Small: 4.46s (1.48x)
Medium: 36.4s (1.53x)
Big: 151.2s (1.54x)
</code></pre><p>That&rsquo;s it mana is depleted. Any more attempts at inlining only gave worse resutls. Despite my expectations, even <code>-</code> and <code>+</code> operations on vectors are faster as they are now, as function calls.</p>
<h2 id="black-magic">Black magic</h2>
<p>As you could have noticed, during all those optimisations the actual code did not change a bit. Well. Its time to test its effectiveness.</p>
<p>First thing that jumped out to me was <code>sphere_intersection</code> and the amount of memory it was allocating. 20% of all allocaitons!</p>
<pre tabindex="0"><code>COST CENTRE           MODULE                 %time %alloc

hit_dist              Hittable               23.6   18.1
sphere_intersection   Hittable               14.6   19.4
color_ray             Main                   7.7    7.6
</code></pre><p>Here&rsquo;s the actual code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">hit_dist</span> ray (tmin, tmax) <span style="color:#f92672">=</span> headMay 
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">.</span> filter (<span style="color:#f92672">&gt;=</span>tmin) <span style="color:#f92672">.</span> filter (<span style="color:#f92672">&lt;=</span>tmax)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;=&lt;</span> sphere_intersection ray
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sphere_intersection</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Ray</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Sphere</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> [<span style="color:#66d9ef">Double</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sphere_intersection</span> (<span style="color:#66d9ef">Ry</span> origin dir) (<span style="color:#66d9ef">Sph</span> center r <span style="color:#66d9ef">_</span> ) <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> discriminant <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">Just</span> [
</span></span><span style="display:flex;"><span>            (<span style="color:#f92672">-</span>b_half <span style="color:#f92672">-</span> sqrt discriminant) <span style="color:#f92672">/</span> a,
</span></span><span style="display:flex;"><span>            (<span style="color:#f92672">-</span>b_half <span style="color:#f92672">+</span> sqrt discriminant) <span style="color:#f92672">/</span> a
</span></span><span style="display:flex;"><span>        ]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">Nothing</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span> <span style="color:#f92672">...</span>
</span></span></code></pre></div><p>It was decided to:</p>
<ol>
<li>Get rid of the list return type. We do know the exact amount of return values.</li>
<li>Rewrite <code>hit_dist</code>, function that uses <code>sphere_intersection</code> in a more imperative style.</li>
</ol>
<p>Firstly, change parenthesis and return type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">sphere_intersection</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Ray</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Sphere</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> (<span style="color:#66d9ef">Double</span>, <span style="color:#66d9ef">Double</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sphere_intersection</span> (<span style="color:#66d9ef">Ry</span> origin dir) (<span style="color:#66d9ef">Sph</span> center r <span style="color:#66d9ef">_</span> ) <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> discriminant <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">Just</span> (
</span></span><span style="display:flex;"><span>            (<span style="color:#f92672">-</span>b_half <span style="color:#f92672">-</span> sqrt discriminant) <span style="color:#f92672">/</span> a,
</span></span><span style="display:flex;"><span>            (<span style="color:#f92672">-</span>b_half <span style="color:#f92672">+</span> sqrt discriminant) <span style="color:#f92672">/</span> a
</span></span><span style="display:flex;"><span>        ) 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">Nothing</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span></code></pre></div><p>And then imperatively filter two values:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">hit_dist</span> ray (tmin, tmax) sph <span style="color:#f92672">=</span> sphere_intersection ray sph <span style="color:#f92672">&gt;&gt;=</span>
</span></span><span style="display:flex;"><span>        (<span style="color:#a6e22e">\</span>(x0, x1) <span style="color:#f92672">-&gt;</span>  <span style="color:#66d9ef">if</span> x0 <span style="color:#f92672">&lt;</span> tmin <span style="color:#f92672">||</span> x0 <span style="color:#f92672">&gt;</span> tmax <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">if</span> x1 <span style="color:#f92672">&gt;</span> tmax <span style="color:#f92672">||</span> x1 <span style="color:#f92672">&lt;</span> tmin <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">Nothing</span>
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">Just</span> x1
</span></span><span style="display:flex;"><span>                       <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">Just</span> x0
</span></span><span style="display:flex;"><span>        )
</span></span></code></pre></div><p>Results:</p>
<pre tabindex="0"><code>Small: 3.67s (1.21x)
Medium: 30.65s (1.19x)
Big: 128.29s (1.18x)
</code></pre><p>And it keeps on giving. Okay, lets keep working on it then. Running under profiler again and reasoning about results:</p>
<pre tabindex="0"><code>COST CENTRE           MODULE                 %time %alloc

hit_dist              Hittable               17.4    1.4
sphere_intersection   Hittable               13.0   20.1
color_ray             Main                   9.7    9.5
</code></pre><p>Hmm&hellip; At least, hit_dist memory consumption decreased. Maybe its possible to optimise it further. However, I&rsquo;m out of ideas here.</p>
<p>So I decided to turn my attention to <code>hit_data</code> - function that collects a complete information structure about possible hit from ray intersecting an object: point, normal, material. Here it is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">hit_data</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Ray</span> <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">Double</span>, <span style="color:#66d9ef">Double</span>) <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">HitData</span>
</span></span><span style="display:flex;"><span>    hit_data ray bounds obj <span style="color:#f92672">=</span> (,,)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;$&gt;</span> hit_point ray bounds obj
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;*&gt;</span> hit_normal ray bounds obj
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;*&gt;</span> hit_material ray bounds obj
</span></span></code></pre></div><p>This is an automatically generated function i.e. we need to specify <code>hit_point</code>, <code>hit_normal</code>, <code>hit_material</code> and woosh - we can use <code>hit_data</code>. There are a couple of things that bother me about it:</p>
<ol>
<li>For each of the functions we probably need to calculate a ray-object intersection. It could be cached by Haskell since its a pure function, but who knows. And, well, going to cache multiple times is still slower than not doing that at all.</li>
<li>Each of the applicative functors must check whether the value is Nothing or not. But we know, that if there is a point, there must be a normal and a material.</li>
</ol>
<p>Solving problem №2 I rewrote hit_data with a more imperative style:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">hit_data</span> ray bounds obj <span style="color:#f92672">=</span>  <span style="color:#66d9ef">case</span> hit_point ray bounds obj <span style="color:#66d9ef">of</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">Nothing</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Nothing</span>
</span></span><span style="display:flex;"><span>        (<span style="color:#66d9ef">Just</span> point) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Just</span> (point, normal, material)
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">where</span> normal <span style="color:#f92672">=</span> fromJust <span style="color:#f92672">$</span> hit_normal ray bounds obj
</span></span><span style="display:flex;"><span>								 material <span style="color:#f92672">=</span> fromJust <span style="color:#f92672">$</span> hit_material ray bounds obj
</span></span></code></pre></div><p>That didn&rsquo;t help much:</p>
<pre tabindex="0"><code>Small: 3.64s (1x)
Medium: 29.16s (1.05x)
Big: 126.3s (1.015x)
</code></pre><p>Solving problem №1 I decided to specialize the function for each object. In our case its just spheres and arrays of spheres:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#75715e">-- Sphere</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_data</span> ray bounds sphere <span style="color:#f92672">=</span> hit_dist ray bounds sphere
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;&amp;&gt;</span> (<span style="color:#a6e22e">\</span>dist <span style="color:#f92672">-&gt;</span> (point dist, normal (outward_normal dist), material sphere))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">where</span> point <span style="color:#f92672">=</span> atPoint ray
</span></span><span style="display:flex;"><span>              outward_normal dist <span style="color:#f92672">=</span> norm <span style="color:#f92672">$</span> point dist <span style="color:#f92672">-</span> center sphere
</span></span><span style="display:flex;"><span>              normal outw <span style="color:#f92672">=</span> (negate <span style="color:#f92672">.</span> signum <span style="color:#f92672">.</span> dot (dir ray) <span style="color:#f92672">$</span> outw) <span style="color:#f92672">*&gt;&gt;</span> outw
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- (Hittable a) =&gt; Hittable [a]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hit_data</span> ray bounds obj <span style="color:#f92672">=</span> hit_data ray bounds <span style="color:#f92672">&lt;=&lt;</span> snd
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">$</span> hit_nearest_sph ray bounds obj
</span></span></code></pre></div><p>And that did something!</p>
<pre tabindex="0"><code>Small: 2.68s (1.37x)
Medium: 21.85s (1.40x)
Big: 90.95s (1.41x)
</code></pre><p>Astounding results. It once again is comparable with going multithreaded on two cores.</p>
<h1 id="are-ya-winning-son">Are ya winning son?</h1>
<p>Lets summarize all results achieved with blood and sweat:</p>
<ol>
<li>Proper multithreading (4 threads) - 1.62x</li>
<li>Compilation flags - 1.05x</li>
<li>Dumb inlining - 1.53x</li>
<li>Algorithm fixes - 1.68x</li>
</ol>
<p>Total speedup - 4.37x
For each configuration:</p>
<pre tabindex="0"><code>Small: 4.22x
Medium: 4.32x
Big: 4.5x
</code></pre><p>Needless to say, there are still ways to improve performance of our raytracer. We could experiment with strictness, arrays and other datastructures. However, speedups won&rsquo;t be on the same scale.</p>
<h1 id="afterword-from-2025">Afterword from 2025</h1>
<p>It was fun to look back at this. But with my since acquired experience it looks like child&rsquo;s play. Doing it over again I would change some things:</p>
<ol>
<li>Better performance metrics. For optimisation it is very important to get quality information. I would probably setup some reproducible benchmark suite that could be run with one command. It would do a number of measurements and then display stats: avg, median, dispersion. And I would run a the benchmark on a couple machines before making conclusions. As it is done now, even the exact settings for configurations are lost.</li>
<li>I would not play with inlining. Performance benefit from heavy inlining probably were a hardware peculialiry as my friend&rsquo;s machine did not experience them as much as mine. Maybe this is a result of a slow memory subsystem? Or a bad prefetcher? Either way, I would be much more careful with inlining.</li>
</ol>
<p>And yeah, heavy speedups are still possible. At least, there are various tree-ish data structures for traversing collections of objects.</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>

    
    <script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
  </body>
</html>
