<!doctype html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <title>Parallelizing Haskel Raytracer // theblek</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.136.5">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Kuklin Georgiy" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.5b1fcc8902588589c4767187402a3c29f8b8d7a6fdef6d9f8f77045bb0d14fee.css" />
    

    
    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Parallelizing Haskel Raytracer">
  <meta name="twitter:description" content="This is just a translation of my previous article from 2023. While I tried to save style from the orignal, most of it It will not be substantially expanded upon, although I might add new measurements later. You can read original in russian here: https://luxurious-yearde9.notion.site/Parallel-Haskell-raytracer-63132332960f488aaa04b7cc01e13f8e.
Introduction So we made a raytracer in haskell using Raytracing In One Weekend as our guide. As you may know, haskell’s biggest feature is mathematically correct functions. Meaning the result of the evaluation can be determined solely from the arugments. So no more global or hidden state. This computing models lends itself great to parrallel execution. However there were a few unexpected pitfalls that I want to share.">

    <meta property="og:url" content="//localhost:1313/posts/haskell-raytracer/">
  <meta property="og:site_name" content="theblek">
  <meta property="og:title" content="Parallelizing Haskel Raytracer">
  <meta property="og:description" content="This is just a translation of my previous article from 2023. While I tried to save style from the orignal, most of it It will not be substantially expanded upon, although I might add new measurements later. You can read original in russian here: https://luxurious-yearde9.notion.site/Parallel-Haskell-raytracer-63132332960f488aaa04b7cc01e13f8e.
Introduction So we made a raytracer in haskell using Raytracing In One Weekend as our guide. As you may know, haskell’s biggest feature is mathematically correct functions. Meaning the result of the evaluation can be determined solely from the arugments. So no more global or hidden state. This computing models lends itself great to parrallel execution. However there were a few unexpected pitfalls that I want to share.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-19T18:27:50+03:00">
    <meta property="article:modified_time" content="2025-06-19T18:27:50+03:00">


  </head>
  <body>
    <header class="app-header">
      <a href="/"><img class="app-header-avatar" src="/myavatar.jpg" alt="Kuklin Georgiy" /></a>
      <span class="app-header-title">theblek</span>
      <p>Software engineer interested in the nitty-gritty of computing</p>
      <div class="app-header-social">
        
          <a href="https://github.com/TheBlek" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentColor"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
          </a>
        
          <a href="https://t.me/theblek_games" target="_blank" rel="noreferrer noopener me">
            <svg class="icon icon-brand-telegram" viewBox="0 0 24 24" fill="currentColor"><title>Telegram</title><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/></svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Parallelizing Haskel Raytracer</h1>
      <div class="post-meta">
        <div>
          <svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
          Jun 19, 2025
        </div>
        <div>
          <svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
          5 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <blockquote>
<p>This is just a translation of my previous article from 2023. While I tried to save style from the orignal, most of it It will not be
substantially expanded upon, although I might add new measurements later. You
can read original in russian here: <a href="https://luxurious-yearde9.notion.site/Parallel-Haskell-raytracer-63132332960f488aaa04b7cc01e13f8e">https://luxurious-yearde9.notion.site/Parallel-Haskell-raytracer-63132332960f488aaa04b7cc01e13f8e</a>.</p>
</blockquote>
<h1 id="introduction">Introduction</h1>
<p>So we made a raytracer in haskell using <a href="https://raytracing.github.com">Raytracing In One Weekend</a> as our guide.
As you may know, haskell&rsquo;s biggest feature is mathematically correct functions. Meaning the result of the evaluation can be determined solely from the arugments. So no more global or hidden state. This computing models lends itself great to parrallel execution. However there were a few unexpected pitfalls that I want to share.</p>
<p>While measuring performance benefit of parallelizing I also became interested in how fast it can go. Hence a second part about optimisations.</p>
<h1 id="baseline-measurements">Baseline measurements</h1>
<p>For all measurements I&rsquo;m going to use three configurations:</p>
<pre tabindex="0"><code>Small: 11.33s (Avg 3)
Medium: 94.5s (Avg 3)
Big: 408.93s (Just 1)
</code></pre><p>Everything later will be measured one-shot.</p>
<h1 id="threads-go-brrr">Threads go brrr</h1>
<p>Having downloaded package <code>parallel</code>, I replaced following line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">write_file</span> <span style="color:#e6db74">&#34;output.ppm&#34;</span> (evalState colors (mkStdGen <span style="color:#ae81ff">0</span>))
</span></span></code></pre></div><p>with</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">write_file</span> <span style="color:#e6db74">&#34;output.ppm&#34;</span> (evalState colors (mkStdGen <span style="color:#ae81ff">0</span>) `using` parList rseq)
</span></span></code></pre></div><p>Just calculating an array of colors for each pixel in parallel. And&hellip;</p>
<p>12 seconds for small configuration&hellip;</p>
<p>And I could see only one thread in htop.</p>
<p>That&rsquo;s because mutlithreading needs to be turned on at compile time:</p>
<pre tabindex="0"><code>ghc-options: 
    -threaded 
    -rtsopts 
    -with-rtsopts=-N -- Can pass number of threads to limit (-N4)
</code></pre><p>Now we are ready to take off!</p>
<p><img src="/haskell-htop.webp" alt="How it look in htop"></p>
<p>Looking good!</p>
<p>Wait, what?&hellip;</p>
<p>24 seconds on the small test?&hellip; From baseline of 11.3?!</p>
<p>Something&rsquo;s wrong here.</p>
<p>This might happen because of resource contension between threads. And we actually have a resource that we &ldquo;share&rdquo; - random number generator. We can&rsquo;t generate random numbers for one pixel until we have done so for previous pixel. Otherwise numbers will be the same for each pixel and won&rsquo;t be random. And empirically that leads to artifacts in the image. So what do we when we actually want to share?</p>
<blockquote>
<p>Looking at this code now in 2025, I&rsquo;m not sure anymore what caused such a massive slowdown. Maybe it&rsquo;s because of spawning so many thread simutaneously? I mean, obviously, it wasn&rsquo;t &ldquo;sharing&rdquo;. Remember - no direct sharing in haskell. However, fundamentally we <em>needed</em> to share pRNG. And that certainly is a limiter. I&rsquo;m not even sure what the code written the first time parallelized&hellip;</p>
</blockquote>
<p>Our case is pretty simple - we can create any number of pRNGs and use each of them sequentially:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> accumulated_color <span style="color:#f92672">=</span> [multi_color objs u v (floor samples_per_pixel)<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>            v <span style="color:#f92672">&lt;-</span>  reverse [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>(image_height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">..</span><span style="color:#ae81ff">1</span>], 
</span></span><span style="display:flex;"><span>            u <span style="color:#f92672">&lt;-</span>  [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>(image_width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">..</span><span style="color:#ae81ff">1</span>]]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> image_height <span style="color:#f92672">*</span> image_width
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> part_len <span style="color:#f92672">=</span> len <span style="color:#f92672">/</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> map_colors <span style="color:#f92672">=</span> mapM (fmap (adjust_gamma <span style="color:#ae81ff">2</span> <span style="color:#f92672">.</span> average samples_per_pixel))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> st_colors <span style="color:#f92672">=</span> map map_colors (chunksOf (floor part_len) accumulated_color)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> colors_parts <span style="color:#f92672">=</span> zipWith (<span style="color:#a6e22e">\</span>st i <span style="color:#f92672">-&gt;</span> evalState st (mkStdGen i)) st_colors [<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> colors <span style="color:#f92672">=</span> concat (colors_parts `using` parList rseq)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">write_file</span> <span style="color:#e6db74">&#34;output.ppm&#34;</span> colors
</span></span></code></pre></div><p>Running small test we get 13 seconds. That&rsquo;s better, but still bad. What am I doing wrong?</p>
<h2 id="haskell-is-a-lazy-capybara">Haskell is a lazy capybara</h2>
<p>Turns out, problem was because of haskell does not evaluate anything immediately. It stores objects that describe the calculation that is evaluated on demand.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>sprint x
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">_</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> seq x ()
</span></span><span style="display:flex;"><span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>sprint x
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>That also applies to <em>constructors of types</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">let</span> z <span style="color:#f92672">=</span> swap (x, x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>sprint z
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">_</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> seq z ()
</span></span><span style="display:flex;"><span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>sprint z
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">_</span>,<span style="color:#66d9ef">_</span>)
</span></span></code></pre></div><p>As you can notice, field values remain uncomputed. As it turns out, <code>seq</code> will not go deeper than one level. To compute field values, you need to demand them:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> fst z
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>sprint z
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> (<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">3</span>)
</span></span></code></pre></div><p>In this case, first field (x + 1) was dependent upon evaluation of x so haskell automatically calculated x. And second field happened to be x, hence its evaluated.</p>
<p>The function that we used to calculate list in parallel - <code>parList</code> - just uses <code>seq</code> on each of the list element in parallel. You can probably see the problem:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Color</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Cl</span> {color<span style="color:#f92672">::</span><span style="color:#66d9ef">Vec3</span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">---</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">let</span> color <span style="color:#f92672">=</span> blue
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>sprint color
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">color</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">_</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> seq color ()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">color</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Cl</span> <span style="color:#66d9ef">_</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">---</span>
</span></span><span style="display:flex;"><span>[<span style="color:#66d9ef">Cl</span> <span style="color:#66d9ef">_</span>, <span style="color:#66d9ef">Cl</span> <span style="color:#66d9ef">_</span>, <span style="color:#f92672">...</span>]
</span></span></code></pre></div><p>And actual colors were calculated when function writing the image needed them.</p>
<p>For solving this problem there is a class <code>RNFData</code> in the <code>deepseq</code> package. This class has a single function that has to make haskell evaluate a value completely. For parallelizing computation of colors we needed to specify the behaviour for our types:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">NFData</span> <span style="color:#66d9ef">Color</span> <span style="color:#66d9ef">where</span> 
</span></span><span style="display:flex;"><span>    rnf (<span style="color:#66d9ef">Cl</span> x) <span style="color:#f92672">=</span> rnf x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">NFData</span> <span style="color:#66d9ef">Vec3</span> <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    rnf (<span style="color:#66d9ef">Vc3</span> x y z) <span style="color:#f92672">=</span> seq x <span style="color:#f92672">$</span> seq y <span style="color:#f92672">$</span> seq z ()
</span></span></code></pre></div><p>Then replace one line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> colors <span style="color:#f92672">=</span> concat (colors_parts `using` parList rdeepseq)
</span></span></code></pre></div><p>And finally a W:</p>
<pre tabindex="0"><code>Small: 8s (~1.41x)
Medium: 64s (~1.47x)
Big: 277s (~1.48x)
</code></pre><p>For a machine with two real cores, the result looks as expected.</p>
<h1 id="optimisations-go-brrr">Optimisations go brrr</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="another-point">Another point</h2>
<p><a href="https://google.com">link</a></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
